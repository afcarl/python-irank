#!/usr/bin/env python
import os
import subprocess
import gpod
import sys
from hashlib import sha1
from collections import defaultdict

IGNORED_PLAYLISTS = (
	"unrated",
)

def exclude(name):
	return name not in ('new','car','new_good')
	return name.startswith("rating") or name in IGNORED_PLAYLISTS


def main(playlist_path, pod_path):
	gpod.Database._load_gtkpod_extended_info = lambda *a: None # I am a very bad man
	run_with_progress(lambda cb: Sync(playlist_path, pod_path).run(cb))

class Sync(object):
	def __init__(self, playlist_path, pod_path):
		self.playlist_path = os.path.expanduser(playlist_path)
		self.pod_path = os.path.expanduser(pod_path)
		self.db = gpod.Database(pod_path)
	
	def playlist_names(self):
		"return a map of folder_name -> playlist_name"
		playlists = []
		for dir in os.listdir(self.playlist_path):
			if exclude(dir): continue
			playlists.append(dir)
		return playlists

	def fingerprint(self, path):
		with open(path, 'rb') as file:
			return (sha1(file.read(1024 * 100)).hexdigest())

	def song_ids(self, paths, on_scan=None):
		ids = {}
		for path in paths:
			try:
				id = self.fingerprint(path)
				if id in ids:
					raise RuntimeError("duplicate key %s for %s and %s" % (id, ids[id], path))
				ids[id] = path
			except IOError:
				print "Skipping: %s" % (path,)
			if on_scan: on_scan()
		return ids
	
	def song_mapping(self):
		"mapping of {song_path : [playlist_key1, playlist_key2...]}"
		song_mappings = defaultdict(lambda: [])
		base_len = len(self.playlist_path)
		for path, dirnames, filenames in os.walk(self.playlist_path):
			for filename in filenames:
				relative_path = os.path.join(path, filename)[base_len:]
				playlist, relative_path = relative_path.split(os.path.sep, 1)
				if exclude(playlist): break
				song_mappings[relative_path].append(playlist)
		return song_mappings

	def get_playlist(self, name):
		"get playlist by name"
		for playlist in self.db.Playlists:
			if playlist.name == name:
				return playlist
		return None

	def remove_all_playlists(self):
		"remove all playlists in the ipod DB"
		for playlist in self.db.Playlists:
			if playlist.master: continue
			#self.db.remove(playlist, quiet=True)
	
	def trim_existing_songs(self, current_song_paths, on_scan=None):
		"remove all songs from the ipod that do not appear in any current playlist"
		active_ids = self.song_ids(current_song_paths, on_scan)
		new_songs = set(current_song_paths)
		master = self.db.get_master()
		for track in master:
			path = track.ipod_filename()
			if on_scan: on_scan()
			if path is None:
				print "no path for track %s" % (track,)
				self.db.remove(track)
				continue
			else:
				print "ok"
			track_id = self.fingerprint(path)
			try:
				new_songs.remove(active_ids[track_id])
			except KeyError:
				self.db.remove(track, quiet=True)
		return new_songs

	def create_playlists(self, names):
		"create all named playlists, if they do not exist"
		mappings = {}
		for name in names:
			pretty_name = name.replace("_"," ")
			playlist = self.get_playlist(pretty_name)
			if playlist is None:
				playlist = self.db.new_Playlist(title=pretty_name)
			mappings[name] = playlist
		return mappings
		
	def sync_tracks(self, song_mapping, playlist_mapping, progress_cb):
		"assign each track to all playlists it is a member of"
		for song_path, folders in song_mapping.items():
			path = os.path.join(self.playlist_path, folders[0], song_path)
			try:
				t = self.db.new_Track(filename = path)
				for playlist_key in folders:
					playlist_mapping[playlist_key].add(t)
			except TypeError,e :
				print "ERROR: %s - %s :: %s" % (type(e).__name__, e, path)

	def run(self, progress_cb):
		"run the sync"
		playlists = self.playlist_names()

		print "grabbing song<->playlist mappings"
		song_mapping = self.song_mapping()
		local_song_files = len(song_mapping.keys())
		songs_on_ipod = len(self.db.get_master())
		progress = Progress(songs_on_ipod + (local_song_files * 2))

		print "clearing DB"
		self.remove_all_playlists()

		print "clearing out old tracks..."
		def on_song_scan():
			progress.inc()
			if progress.current % 10 == 0:
				progress_cb(progress.total, progress.current, "Scanning ... (%s of %s)" % (progress.current, progress.total))
		song_paths = (os.path.join(dirs[0], file) for file, dirs in song_mapping.items())
		new_songs = self.trim_existing_songs(song_paths, on_song_scan)

		print "getting playlist mapping"
		playlist_mapping = self.create_playlists(playlists)
		
		print "Syncing items"
		def done_item():
			progress.inc()
			progress_cb(progress.total, progress.current, "Updating ... (%s of %s)" % (progress.current, progress.total))
		self.sync_tracks(song_mapping, playlist_mapping, done_item)
		
		progress.reset(len(new_songs))
		print "%s new songs to copy to ipod" % (progress.total,)
		def file_copied(*a):
			progress.inc()
			progress_cb(progress.total, progress.current, "Copying files to the iPod ... (%s of %s)" % (progress.current, progress.total))

		self.db.copy_delayed_files(callback=file_copied)
		self.db.close()
		print "All done."

class Progress(object):
	def __init__(self, total=100):
		self.total = total
		self.current = 0
	
	def reset(self, total=None):
		if total is not None:
			self.total = total
		self.current = 0
	
	def inc(self):
		self.current += 1

def run_with_progress(payload):
	"""
	Wrapper to run an arbitrary function inside a progress bar.
	It will supply the function a single argument, which is the progress_callback.
	progress_callback takes (total, current, title) and uses it to
	update the progress bar window
	"""
	null = open(os.devnull, 'w')
	success = True

	progress_bar = subprocess.Popen(["zenity", "--progress", "--auto-close"], stdin=subprocess.PIPE, stdout = null)
	def close_progress_bar():
		if progress_bar.returncode is not None:
			progress_bar.stdin.close()
			progress_bar.terminate()
			progress_bar.kill()
	
	def callback(total, current, title):
		if progress_bar.returncode is not None:
			# progress bar got cancelled
			raise KeyboardInterrupt()
		percent = int((current * 100.0) / max(total,1))
		progress_bar.stdin.write("%d\n" % (min(percent, 99),))
		progress_bar.stdin.write("#%s\n" % (title,))
		progress_bar.stdin.flush()

	try:
		payload(callback)
		close_progress_bar()
	except KeyboardInterrupt:
		print "Cancelled"
		success = False
	except IOError:
		print "Cancelled"
		success = False
	finally:
		close_progress_bar()
		null.close()
	return success

# main wrapper
if __name__ == '__main__':
	args = sys.argv[1:]
	if len(args) != 2:
		print "Usage: %s <playlists> <ipod>" % (os.path.basename(sys.argv[0]),)
		sys.exit(1)
	main(*args)
