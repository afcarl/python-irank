#!/usr/bin/env python
import os
import subprocess
import gpod
import sys
from hashlib import sha1
from collections import defaultdict

IGNORED_PLAYLISTS = (
	"unrated",
)
MASTER = '@master'

def exclude(name):
	return name not in ('new','car','new_good')
	return name.startswith("rating") or name in IGNORED_PLAYLISTS


def main():
	import optparse
	parser = optparse.OptionParser("Usage: %prog <playlists> <ipod>")
	parser.add_option('--check', '-c', action='store_true')
	parser.add_option('--dry-run', action='store_true')
	opts, args = parser.parse_args()
	playlist_path = pod_path = None
	try:
		playlist_path, pod_path = args
	except StandardError, e:
		parser.print_usage(file = sys.stderr)
		sys.exit(1)
	if opts.check:
		return check(pod_path)
	return sync(playlist_path, pod_path, opts.dry_run)

def check(pod_path):
	sync = Sync('', pod_path)
	bad_tracks = sync.invalid_tracks()
	if not bad_tracks:
		print >> sys.stderr, "no orphan files!"
		sys.exit(0)
	else:
		print >> sys.stderr, " == bad tracks: == "
		for track in bad_tracks:
			print "%s%s" % (pod_path, track['ipod_path'].replace(':','/'))
			sync.db.remove(track)
		sync.db.close()
		sys.exit(1)

def sync(playlist_path, pod_path, dry_run):
	gpod.Database._load_gtkpod_extended_info = lambda *a: None # I am a very bad man
	run_with_progress(lambda cb: Sync(playlist_path, pod_path, dry_run).run(cb))

class Sync(object):
	def __init__(self, playlist_path, pod_path, dry_run):
		self.playlist_path = os.path.expanduser(playlist_path)
		self.pod_path = os.path.expanduser(pod_path)
		self.db = gpod.Database(pod_path)
		self.dry_run = dry_run
	
	def playlist_names(self):
		"return a map of folder_name -> playlist_name"
		playlists = []
		for dir in os.listdir(self.playlist_path):
			if exclude(dir): continue
			playlists.append(dir)
		return playlists

	def fingerprint(self, path):
		with open(path, 'rb') as file:
			return (sha1(file.read(1024 * 100)).hexdigest())
	
	def invalid_tracks(self):
		invalids = set()
		master = self.db.get_master()
		for track in master:
			path = track.ipod_filename()
			if path is None:
				invalids.add(track)
		return invalids

	def song_ids(self, paths, on_scan=None):
		ids = {}
		for path in paths:
			try:
				id = self.fingerprint(os.path.join(self.playlist_path, path))
				if id in ids:
					raise RuntimeError("duplicate key %s for %s and %s" % (id, ids[id], path))
				ids[id] = path
			except IOError, e:
				print "Skipping %s: %s" % (path, e)
			if on_scan: on_scan()
		return ids
	
	def song_mapping(self):
		"mapping of {song_path : [playlist_key1, playlist_key2...]}"
		song_mappings = defaultdict(lambda: [])
		base_len = len(self.playlist_path)
		for path, dirnames, filenames in os.walk(self.playlist_path):
			for filename in filenames:
				relative_path = os.path.join(path, filename)[base_len:]
				playlist, relative_path = relative_path.split(os.path.sep, 1)
				if exclude(playlist): break
				song_mappings[relative_path].append(playlist)

		for mapping in song_mappings.values():
			mapping.append(MASTER)
		return song_mappings

	def get_playlist(self, name):
		"get playlist by name"
		for playlist in self.db.Playlists:
			if playlist.name == name:
				return playlist
		return None

	def trim_existing_songs(self, current_song_paths, on_scan=None):
		"remove all songs from the ipod that do not appear in any current playlist"
		active_ids = self.song_ids(current_song_paths, on_scan)
		new_songs = set(current_song_paths)
		master = self.db.get_master()
		num_already_present = 0
		num_new = 0
		to_remove = set()
		for track in master:
			path = track.ipod_filename()
			if on_scan: on_scan()
			if path is None:
				print "no path for %s" % (track,)
				to_remove.add(track)
				continue
			track_id = self.fingerprint(path)
			try:
				new_songs.remove(active_ids[track_id])
				num_already_present += 1
			except KeyError:
				if not self.dry_run: self.db.remove(track, quiet=True)
				num_new += 1
		if not self.dry_run:
			for track in to_remove:
				self.db.remove(track)
		print "after trimming songs, new = %s and already_present = %s" % (num_new, num_already_present)
		return new_songs

	def create_playlists(self, names):
		"create all named playlists, if they do not exist"
		mappings = {}
		names = names[:]
		names.append(MASTER)
		def pretty(name):
			return name.replace("_"," ")
		pretty_names = map(pretty, names)

		to_remove = []
		for playlist in self.db.Playlists:
			if playlist.master or playlist.name == MASTER: continue
			print "removing playlist: %s" % (playlist.name,)
			to_remove.append(playlist)
		if not self.dry_run:
			for playlist in to_remove:
				self.db.remove(playlist, quiet=True)

		for name, pretty_name in zip(names, pretty_names):
			playlist = self.get_playlist(pretty_name)
			if playlist is None:
				print "adding playlist: %s" % (pretty_name,)
				playlist = self.db.new_Playlist(title=pretty_name)
			mappings[name] = playlist
		return mappings
		
	def sync_tracks(self, song_mapping, playlist_mapping, progress_cb):
		"assign each track to all playlists it is a member of"
		for song_path, folders in song_mapping.items():
			path = os.path.join(self.playlist_path, folders[0], song_path)
			try:
				t = self.db.new_Track(filename = path)
				for playlist_key in folders:
					playlist_mapping[playlist_key].add(t)
			except TypeError,e :
				print "ERROR: %s - %s :: %s" % (type(e).__name__, e, path)

	def run(self, progress_cb):
		"run the sync"
		playlists = self.playlist_names()

		print "grabbing song<->playlist mappings"
		song_mapping = self.song_mapping()
		local_song_files = len(song_mapping.keys())
		songs_on_ipod = len(self.db.get_master())
		progress = Progress(songs_on_ipod + local_song_files)

		print "Scanning for duplicates..."
		def on_song_scan():
			progress.inc()
			if progress.current % 10 == 0:
				progress_cb(progress.total, progress.current, "Scanning ... (%s of %s)" % (progress.current, progress.total))
		song_paths = set((os.path.join(dirs[0], file) for file, dirs in song_mapping.items()))
		new_songs = self.trim_existing_songs(song_paths, on_song_scan)

		print "getting playlist mapping"
		playlist_mapping = self.create_playlists(playlists)
		
		print "Syncing items"
		def done_item():
			progress.inc()
			progress_cb(progress.total, progress.current, "Updating ... (%s of %s)" % (progress.current, progress.total))

		if not self.dry_run:
			self.sync_tracks(song_mapping, playlist_mapping, done_item)
		
		progress.reset(len(new_songs))
		print "%s new songs to copy to ipod" % (progress.total,)
		def file_copied(*a):
			progress.inc()
			progress_cb(progress.total, progress.current, "Copying files to the iPod ... (%s of %s)" % (progress.current, progress.total))

		self.db.copy_delayed_files(callback=file_copied)
		self.db.close()
		print "All done."

class Progress(object):
	def __init__(self, total=100):
		self.total = total
		self.current = 0
	
	def reset(self, total=None):
		if total is not None:
			self.total = total
		self.current = 0
	
	def inc(self):
		self.current += 1

def run_with_progress(payload):
	"""
	Wrapper to run an arbitrary function inside a progress bar.
	It will supply the function a single argument, which is the progress_callback.
	progress_callback takes (total, current, title) and uses it to
	update the progress bar window
	"""
	null = open(os.devnull, 'w')
	success = True

	progress_bar = subprocess.Popen(["zenity", "--progress", "--auto-close"], stdin=subprocess.PIPE, stdout = null)
	def close_progress_bar():
		if progress_bar.returncode is not None:
			progress_bar.stdin.close()
			progress_bar.terminate()
			progress_bar.kill()
	
	def callback(total, current, title):
		if progress_bar.returncode is not None:
			# progress bar got cancelled
			raise KeyboardInterrupt()
		percent = int((current * 100.0) / max(total,1))
		progress_bar.stdin.write("%d\n" % (min(percent, 99),))
		progress_bar.stdin.write("#%s\n" % (title,))
		progress_bar.stdin.flush()

	try:
		payload(callback)
		close_progress_bar()
	except KeyboardInterrupt:
		print "Cancelled"
		success = False
	except IOError:
		print "Cancelled"
		success = False
	finally:
		close_progress_bar()
		null.close()
	return success

# main wrapper
if __name__ == '__main__':
	main()
