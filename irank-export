#!/usr/bin/env python
import os
import tempfile
import shutil
import math
import sys
import subprocess

from irank.config import IrankOptionParser, IrankApp
from irank import db as irank_db
STATUS = 0

def main():
	p = IrankOptionParser('%prog -d DEST playlist_name [playlist_name ...]')
	p.add_option('-d', '--dest', help='export destination', default=None)
	p.add_option('-l', '--limit', type="int", help='per-playlist filesize limit', default=None)
	p.add_option('-i', '--interactive', action='store_true', help='Interactively resolve errors')
	opts, args = p.parse_args()
	assert opts.dest, p.get_usage()
	assert len(args) > 0, p.get_usage()
	app = IrankApp(opts)

	music_base = os.path.expanduser(opts.music)
	irank_base = os.path.expanduser(opts.irank)
	export_base = os.path.expanduser(opts.dest)
	exported_dir = '__master'
	export_music = os.path.join(export_base, exported_dir)
	songs = {}
	all_songs = set()

	for playlist in args:
		playlist_songs = set(app.songs_for(playlist, relative=True))
		songs[playlist] = playlist_songs
		all_songs.update(playlist_songs)
		print "Queried playlist %s: %s files" % (playlist, len(playlist_songs))
	
	export_temp = os.path.join(irank_base, "__export_temp")
	print "linking into %r ..." % (export_temp,)
	total_size = link_all_files(all_songs, export_temp=export_temp, music_base=music_base, limit=opts.limit)
	try:
		print "Syncing %s files (%0.2fgb)" % (len(all_songs),total_size / (math.pow(1000, 3)))
		sync_opts = []
		syncing = True
		while syncing:
			try:
				sync(export_temp, export_music, additional_opts=sync_opts)
				break
			except (subprocess.CalledProcessError, OSError) as e:
				if not opts.interactive:
					raise
				print >> sys.stderr, "Error syncing: %s\n" % (e,)
				while True:
					print >> sys.stderr, "Press Ctrl-C to abort, 'r' to restart, <return> to continue (skipping existing files) and 's' to skip to next step"
					result = raw_input().strip().lower()
					if result == '':
						sync_opts = ['--ignore-existing']
						break
					elif result == 'r':
						sync_opts = []
						break
					elif result == 's':
						syncing = False
						break
					else:
						print >> sys.stderr, "Eh?"
	finally:
		shutil.rmtree(export_temp)
	for playlist, files in songs.items():
		exported_paths = [os.path.join(exported_dir, name) for name in files]
		print "writing playlist: %s" % (playlist,)
		write_m3u(export_base, playlist, sorted(exported_paths))

def link_all_files(all_songs, export_temp, music_base, limit=None):
	if os.path.exists(export_temp):
		shutil.rmtree(export_temp)
	else:
		os.makedirs(export_temp)
	total_size = 0
	def file_size(path):
		try:
			return os.stat(path).st_size
		except OSError:
			print >> sys.stderr, "couldn't get file size of file: %s" % (path,)
		return None

	for file in all_songs:
		#if not os.path.isdir(os.path.dirname(
		src_file = os.path.join(music_base, file)
		src_file_size = file_size(src_file)
		if src_file_size is None:
			continue
		if limit and (total_size + src_file_size) > limit:
			return total_size
		else:
			total_size += src_file_size

		link_dest = os.path.join(export_temp, file)
		link_dest_dir = os.path.dirname(link_dest)
		if not os.path.isdir(link_dest_dir):
			os.makedirs(link_dest_dir)
		os.link(src_file, link_dest)
	return total_size

def sync(src, dest, additional_opts=[]):
	if not os.path.isdir(dest):
		os.makedirs(dest)
	cmd = [
		'rsync',
		#'-n',
		'--progress',
		'-a',
		#'-v',
		'--delete'] + additional_opts + [src + os.path.sep, dest]
	print "running: %r" % (cmd,)
	subprocess.check_call(cmd, stdin=subprocess.PIPE)

def write_m3u(dest, name, files):
	global STATUS
	encoding = sys.getfilesystemencoding()
	with open(os.path.join(dest, name + '.m3u'), 'w') as output:
		for name in files:
			try:
				print >> output, name.encode(encoding)
			except (UnicodeEncodeError, UnicodeDecodeError) as err:
				print "FAILED to write song: %r" % (name,)
				STATUS = 1

if __name__ == '__main__':
	main()
	sys.exit(STATUS)

